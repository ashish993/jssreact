{"ast":null,"code":"import i18n from 'i18next';\nimport fetchBackend from 'i18next-fetch-backend';\nimport { initReactI18next } from 'react-i18next';\nimport config from './temp/config';\nimport { getHostname } from './util';\n/**\r\n * Initializes the i18next library to provide a translation dictionary to the app.\r\n * If your app is not multilingual, this file and references to it can be removed.\r\n * Elsewhere in the app to use the dictionary `import { t } from 'i18next'; ... t('key')`\r\n * @param {string} language Optional, the initial language. Only used for SSR; otherwise language set in RouteHandler.\r\n * @param {*} dictionary Optional, the dictionary to load. Only used for SSR; otherwise, the dictionary is loaded via JSS dictionary service.\r\n */\n\nexport default function i18nInit(language, dictionary) {\n  return new Promise((resolve, reject) => {\n    var options = {\n      debug: false,\n      lng: language,\n      fallbackLng: false,\n      // fallback to keys\n      load: 'currentOnly',\n      // e.g. don't load 'es' when requesting 'es-MX' -- Sitecore config should handle this\n      useCookie: false,\n      // using URLs and Sitecore to store language context, don't need a cookie\n      interpolation: {\n        escapeValue: false // not needed for react\n\n      }\n    };\n\n    if (dictionary) {\n      // if we got dictionary passed, that means we're in a SSR context with a server-provided dictionary\n      // so we do not want a backend, because we already know all possible keys\n      if (!i18n.isInitialized) {\n        i18n.use(initReactI18next).init(options, error => {\n          if (error) reject(error);\n          i18n.addResourceBundle(language, 'translation', dictionary, true, true);\n          resolve();\n        });\n      } else {\n        i18n.changeLanguage(language).then(() => {\n          i18n.addResourceBundle(language, 'translation', dictionary, true, true);\n          resolve();\n        });\n      }\n    } else {\n      // We're running client-side, so we get translation data from the Sitecore dictionary API using fetch backend\n      // For higher performance (but less simplicity), consider adding the i18n chained backend to a local cache option like the local storage backend.\n      // eslint-disable-next-line\n      var dictionaryServicePath = \"\".concat(getHostname(), \"/sitecore/api/jss/dictionary/\").concat(config.jssAppName, \"/{{lng}}?sc_apikey=\").concat(config.sitecoreApiKey);\n      options.backend = {\n        loadPath: dictionaryServicePath,\n        parse: data => {\n          var parsedData = JSON.parse(data);\n\n          if (parsedData.phrases) {\n            return parsedData.phrases;\n          }\n\n          return parsedData;\n        }\n      };\n      i18n.use(fetchBackend).use(initReactI18next).init(options, error => {\n        if (error) reject(error);\n        resolve();\n      });\n    }\n  });\n}","map":{"version":3,"sources":["C:/Users/asha/Documents/ASHA/sitecorejss/test/my-react-jss-app/src/i18n.js"],"names":["i18n","fetchBackend","initReactI18next","config","getHostname","i18nInit","language","dictionary","Promise","resolve","reject","options","debug","lng","fallbackLng","load","useCookie","interpolation","escapeValue","isInitialized","use","init","error","addResourceBundle","changeLanguage","then","dictionaryServicePath","jssAppName","sitecoreApiKey","backend","loadPath","parse","data","parsedData","JSON","phrases"],"mappings":"AAAA,OAAOA,IAAP,MAAiB,SAAjB;AACA,OAAOC,YAAP,MAAyB,uBAAzB;AACA,SAASC,gBAAT,QAAiC,eAAjC;AACA,OAAOC,MAAP,MAAmB,eAAnB;AACA,SAASC,WAAT,QAA4B,QAA5B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,SAASC,QAAT,CAAkBC,QAAlB,EAA4BC,UAA5B,EAAwC;AACrD,SAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtC,QAAMC,OAAO,GAAG;AACdC,MAAAA,KAAK,EAAE,KADO;AAEdC,MAAAA,GAAG,EAAEP,QAFS;AAGdQ,MAAAA,WAAW,EAAE,KAHC;AAGM;AACpBC,MAAAA,IAAI,EAAE,aAJQ;AAIO;AACrBC,MAAAA,SAAS,EAAE,KALG;AAKI;AAElBC,MAAAA,aAAa,EAAE;AACbC,QAAAA,WAAW,EAAE,KADA,CACO;;AADP;AAPD,KAAhB;;AAYA,QAAIX,UAAJ,EAAgB;AACd;AACA;AAEA,UAAI,CAACP,IAAI,CAACmB,aAAV,EAAyB;AACvBnB,QAAAA,IAAI,CAACoB,GAAL,CAASlB,gBAAT,EAA2BmB,IAA3B,CAAgCV,OAAhC,EAA0CW,KAAD,IAAW;AAClD,cAAIA,KAAJ,EAAWZ,MAAM,CAACY,KAAD,CAAN;AAEXtB,UAAAA,IAAI,CAACuB,iBAAL,CAAuBjB,QAAvB,EAAiC,aAAjC,EAAgDC,UAAhD,EAA4D,IAA5D,EAAkE,IAAlE;AAEAE,UAAAA,OAAO;AACR,SAND;AAOD,OARD,MAQO;AACLT,QAAAA,IAAI,CAACwB,cAAL,CAAoBlB,QAApB,EAA8BmB,IAA9B,CAAmC,MAAM;AACvCzB,UAAAA,IAAI,CAACuB,iBAAL,CAAuBjB,QAAvB,EAAiC,aAAjC,EAAgDC,UAAhD,EAA4D,IAA5D,EAAkE,IAAlE;AAEAE,UAAAA,OAAO;AACR,SAJD;AAKD;AACF,KAnBD,MAmBO;AACL;AACA;AAEA;AACA,UAAMiB,qBAAqB,aAAMtB,WAAW,EAAjB,0CAAmDD,MAAM,CAACwB,UAA1D,gCAA0FxB,MAAM,CAACyB,cAAjG,CAA3B;AAEAjB,MAAAA,OAAO,CAACkB,OAAR,GAAkB;AAChBC,QAAAA,QAAQ,EAAEJ,qBADM;AAEhBK,QAAAA,KAAK,EAAGC,IAAD,IAAU;AACf,cAAMC,UAAU,GAAGC,IAAI,CAACH,KAAL,CAAWC,IAAX,CAAnB;;AACA,cAAIC,UAAU,CAACE,OAAf,EAAwB;AACtB,mBAAOF,UAAU,CAACE,OAAlB;AACD;;AACD,iBAAOF,UAAP;AACD;AARe,OAAlB;AAWAjC,MAAAA,IAAI,CACDoB,GADH,CACOnB,YADP,EAEGmB,GAFH,CAEOlB,gBAFP,EAGGmB,IAHH,CAGQV,OAHR,EAGkBW,KAAD,IAAW;AACxB,YAAIA,KAAJ,EAAWZ,MAAM,CAACY,KAAD,CAAN;AAEXb,QAAAA,OAAO;AACR,OAPH;AAQD;AACF,GA3DM,CAAP;AA4DD","sourcesContent":["import i18n from 'i18next';\r\nimport fetchBackend from 'i18next-fetch-backend';\r\nimport { initReactI18next } from 'react-i18next';\r\nimport config from './temp/config';\r\nimport { getHostname } from './util';\r\n\r\n/**\r\n * Initializes the i18next library to provide a translation dictionary to the app.\r\n * If your app is not multilingual, this file and references to it can be removed.\r\n * Elsewhere in the app to use the dictionary `import { t } from 'i18next'; ... t('key')`\r\n * @param {string} language Optional, the initial language. Only used for SSR; otherwise language set in RouteHandler.\r\n * @param {*} dictionary Optional, the dictionary to load. Only used for SSR; otherwise, the dictionary is loaded via JSS dictionary service.\r\n */\r\nexport default function i18nInit(language, dictionary) {\r\n  return new Promise((resolve, reject) => {\r\n    const options = {\r\n      debug: false,\r\n      lng: language,\r\n      fallbackLng: false, // fallback to keys\r\n      load: 'currentOnly', // e.g. don't load 'es' when requesting 'es-MX' -- Sitecore config should handle this\r\n      useCookie: false, // using URLs and Sitecore to store language context, don't need a cookie\r\n\r\n      interpolation: {\r\n        escapeValue: false, // not needed for react\r\n      },\r\n    };\r\n\r\n    if (dictionary) {\r\n      // if we got dictionary passed, that means we're in a SSR context with a server-provided dictionary\r\n      // so we do not want a backend, because we already know all possible keys\r\n\r\n      if (!i18n.isInitialized) {\r\n        i18n.use(initReactI18next).init(options, (error) => {\r\n          if (error) reject(error);\r\n\r\n          i18n.addResourceBundle(language, 'translation', dictionary, true, true);\r\n\r\n          resolve();\r\n        });\r\n      } else {\r\n        i18n.changeLanguage(language).then(() => {\r\n          i18n.addResourceBundle(language, 'translation', dictionary, true, true);\r\n\r\n          resolve();\r\n        });\r\n      }\r\n    } else {\r\n      // We're running client-side, so we get translation data from the Sitecore dictionary API using fetch backend\r\n      // For higher performance (but less simplicity), consider adding the i18n chained backend to a local cache option like the local storage backend.\r\n\r\n      // eslint-disable-next-line\r\n      const dictionaryServicePath = `${getHostname()}/sitecore/api/jss/dictionary/${config.jssAppName}/{{lng}}?sc_apikey=${config.sitecoreApiKey}`;\r\n\r\n      options.backend = {\r\n        loadPath: dictionaryServicePath,\r\n        parse: (data) => {\r\n          const parsedData = JSON.parse(data);\r\n          if (parsedData.phrases) {\r\n            return parsedData.phrases;\r\n          }\r\n          return parsedData;\r\n        },\r\n      };\r\n\r\n      i18n\r\n        .use(fetchBackend)\r\n        .use(initReactI18next)\r\n        .init(options, (error) => {\r\n          if (error) reject(error);\r\n\r\n          resolve();\r\n        });\r\n    }\r\n  });\r\n}\r\n"]},"metadata":{},"sourceType":"module"}