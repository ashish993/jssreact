{"ast":null,"code":"import { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nimport _objectSpread from \"C:/Users/asha/Documents/ASHA/sitecorejss/test/my-react-jss-app/node_modules/react-scripts/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _objectWithoutProperties from \"C:/Users/asha/Documents/ASHA/sitecorejss/test/my-react-jss-app/node_modules/react-scripts/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties\";\nvar _jsxFileName = \"C:\\\\Users\\\\asha\\\\Documents\\\\ASHA\\\\sitecorejss\\\\test\\\\my-react-jss-app\\\\src\\\\RouteHandler.js\";\nimport React from 'react';\nimport i18n from 'i18next';\nimport Helmet from 'react-helmet';\nimport { isExperienceEditorActive, dataApi, withSitecoreContext } from '@sitecore-jss/sitecore-jss-react';\nimport { dataFetcher } from './dataFetcher';\nimport { getHostname } from './util';\nimport config from './temp/config';\nimport Layout from './Layout';\nimport NotFound from './NotFound';\n/* eslint-disable no-console */\n// Dynamic route handler for Sitecore items.\n// Because JSS app routes are defined in Sitecore, traditional static React routing isn't enough -\n// we need to be able to load dynamic route data from Sitecore after the client side route changes.\n// So react-router delegates all route rendering to this handler, which attempts to get the right\n// route data from Sitecore - and if none exists, renders the not found component.\n\nclass RouteHandler extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.extractRouteData = () => {\n      if (!this.props.sitecoreContext) return null;\n\n      var _this$props$sitecoreC = this.props.sitecoreContext,\n          route = _this$props$sitecoreC.route,\n          context = _objectWithoutProperties(_this$props$sitecoreC, [\"route\"]);\n\n      return {\n        sitecore: {\n          route,\n          context\n        }\n      };\n    };\n\n    this.state = {\n      notFound: true,\n      defaultLanguage: config.defaultLanguage\n    };\n    var routeData = this.extractRouteData(); // route data from react-router - if route was resolved, it's not a 404\n\n    if (props.route !== null) {\n      this.state.notFound = false;\n    } // if we have an initial SSR state, and that state doesn't have a valid route data,\n    // then this is a 404 route.\n\n\n    if (routeData && (!routeData.sitecore || !routeData.sitecore.route)) {\n      this.state.notFound = true;\n    } // if we have an SSR state, and that state has language data, set the current language\n    // (this makes the language of content follow the Sitecore context language cookie)\n    // note that a route-based language (i.e. /de-DE) will override this default; this is for home.\n\n\n    if (routeData && routeData.sitecore && routeData.sitecore.context && routeData.sitecore.context.language) {\n      this.state.defaultLanguage = routeData.sitecore.context.language;\n    } // tell i18next to sync its current language with the route language\n\n\n    this.updateLanguage();\n  }\n\n  componentDidMount() {\n    var routeData = this.extractRouteData(); // if no existing routeData is present (from SSR), get Layout Service fetching the route data or ssr render complete\n\n    if (!routeData || this.props.ssrRenderComplete) {\n      this.updateRouteData();\n    }\n  }\n\n  /**\r\n   * Loads route data from Sitecore Layout Service into state.routeData\r\n   */\n  updateRouteData() {\n    var sitecoreRoutePath = this.props.route.match.params.sitecoreRoute || '/';\n\n    if (!sitecoreRoutePath.startsWith('/')) {\n      sitecoreRoutePath = \"/\".concat(sitecoreRoutePath);\n    }\n\n    var language = this.props.route.match.params.lang || this.state.defaultLanguage; // get the route data for the new route\n\n    getRouteData(sitecoreRoutePath, language).then(routeData => {\n      if (routeData !== null && routeData.sitecore && routeData.sitecore.route) {\n        // set the sitecore context data and push the new route\n        this.props.updateSitecoreContext(_objectSpread({\n          route: routeData.sitecore.route,\n          itemId: routeData.sitecore.route.itemId\n        }, routeData.sitecore.context));\n        this.setState({\n          notFound: false\n        });\n      } else {\n        this.setState({\n          notFound: true\n        }, () => {\n          var context = routeData && routeData.sitecore ? routeData.sitecore.context : null;\n          this.props.updateSitecoreContext(context);\n        });\n      }\n    });\n  }\n  /**\r\n   * Updates the current app language to match the route data.\r\n   */\n\n\n  updateLanguage() {\n    var newLanguage = this.props.route.match.params.lang || this.state.defaultLanguage;\n\n    if (i18n.language !== newLanguage) {\n      i18n.changeLanguage(newLanguage);\n    }\n  }\n\n  componentDidUpdate(previousProps) {\n    var existingRoute = previousProps.route.match.url;\n    var newRoute = this.props.route.match.url; // don't change state (refetch route data) if the route has not changed\n\n    if (existingRoute === newRoute) {\n      return;\n    } // if in experience editor - force reload instead of route data update\n    // avoids confusing Sitecore's editing JS\n\n\n    if (isExperienceEditorActive()) {\n      window.location.assign(newRoute);\n      return;\n    }\n\n    this.updateLanguage();\n    this.updateRouteData();\n  }\n\n  render() {\n    var notFound = this.state.notFound;\n    var routeData = this.extractRouteData(); // no route data for the current route in Sitecore - show not found component.\n    // Note: this is client-side only 404 handling. Server-side 404 handling is the responsibility\n    // of the server being used (i.e. node-headless-ssr-proxy and Sitecore intergrated rendering know how to send 404 status codes).\n\n    if (notFound && routeData) {\n      return /*#__PURE__*/_jsxDEV(\"div\", {\n        children: [/*#__PURE__*/_jsxDEV(Helmet, {\n          children: /*#__PURE__*/_jsxDEV(\"title\", {\n            children: i18n.t('Page not found')\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 156,\n            columnNumber: 13\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 155,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(NotFound, {\n          context: routeData.sitecore && routeData.sitecore.context\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 158,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 154,\n        columnNumber: 9\n      }, this);\n    } // Don't render anything if the route data or dictionary data is not fully loaded yet.\n    // This is a good place for a \"Loading\" component, if one is needed.\n\n\n    if (!routeData) {\n      return null;\n    } // Render the app's root structural layout\n\n\n    return /*#__PURE__*/_jsxDEV(Layout, {\n      route: routeData.sitecore.route\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 170,\n      columnNumber: 12\n    }, this);\n  }\n\n}\n/**\r\n * Gets route data from Sitecore. This data is used to construct the component layout for a JSS route.\r\n * @param {string} route Route path to get data for (e.g. /about)\r\n * @param {string} language Language to get route data in (content language, e.g. 'en')\r\n */\n\n\nfunction getRouteData(route, language) {\n  var fetchOptions = {\n    layoutServiceConfig: {\n      host: getHostname()\n    },\n    querystringParams: {\n      sc_lang: language,\n      sc_apikey: config.sitecoreApiKey\n    },\n    fetcher: dataFetcher\n  };\n  return dataApi.fetchRouteData(route, fetchOptions).catch(error => {\n    if (error.response && error.response.status === 404 && error.response.data) {\n      return error.response.data;\n    }\n\n    console.error('Route data fetch error', error, error.response);\n    return null;\n  });\n}\n\nexport default withSitecoreContext({\n  updatable: true\n})(RouteHandler);","map":{"version":3,"sources":["C:/Users/asha/Documents/ASHA/sitecorejss/test/my-react-jss-app/src/RouteHandler.js"],"names":["React","i18n","Helmet","isExperienceEditorActive","dataApi","withSitecoreContext","dataFetcher","getHostname","config","Layout","NotFound","RouteHandler","Component","constructor","props","extractRouteData","sitecoreContext","route","context","sitecore","state","notFound","defaultLanguage","routeData","language","updateLanguage","componentDidMount","ssrRenderComplete","updateRouteData","sitecoreRoutePath","match","params","sitecoreRoute","startsWith","lang","getRouteData","then","updateSitecoreContext","itemId","setState","newLanguage","changeLanguage","componentDidUpdate","previousProps","existingRoute","url","newRoute","window","location","assign","render","t","fetchOptions","layoutServiceConfig","host","querystringParams","sc_lang","sc_apikey","sitecoreApiKey","fetcher","fetchRouteData","catch","error","response","status","data","console","updatable"],"mappings":"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","sourcesContent":["import React from 'react';\r\nimport i18n from 'i18next';\r\nimport Helmet from 'react-helmet';\r\nimport {\r\n  isExperienceEditorActive,\r\n  dataApi,\r\n  withSitecoreContext,\r\n} from '@sitecore-jss/sitecore-jss-react';\r\nimport { dataFetcher } from './dataFetcher';\r\nimport { getHostname } from './util';\r\nimport config from './temp/config';\r\nimport Layout from './Layout';\r\nimport NotFound from './NotFound';\r\n\r\n/* eslint-disable no-console */\r\n\r\n// Dynamic route handler for Sitecore items.\r\n// Because JSS app routes are defined in Sitecore, traditional static React routing isn't enough -\r\n// we need to be able to load dynamic route data from Sitecore after the client side route changes.\r\n// So react-router delegates all route rendering to this handler, which attempts to get the right\r\n// route data from Sitecore - and if none exists, renders the not found component.\r\n\r\nclass RouteHandler extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n\r\n    this.state = {\r\n      notFound: true,\r\n      defaultLanguage: config.defaultLanguage,\r\n    };\r\n\r\n    const routeData = this.extractRouteData();\r\n\r\n    // route data from react-router - if route was resolved, it's not a 404\r\n    if (props.route !== null) {\r\n      this.state.notFound = false;\r\n    }\r\n\r\n    // if we have an initial SSR state, and that state doesn't have a valid route data,\r\n    // then this is a 404 route.\r\n    if (routeData && (!routeData.sitecore || !routeData.sitecore.route)) {\r\n      this.state.notFound = true;\r\n    }\r\n\r\n    // if we have an SSR state, and that state has language data, set the current language\r\n    // (this makes the language of content follow the Sitecore context language cookie)\r\n    // note that a route-based language (i.e. /de-DE) will override this default; this is for home.\r\n    if (\r\n      routeData &&\r\n      routeData.sitecore &&\r\n      routeData.sitecore.context &&\r\n      routeData.sitecore.context.language\r\n    ) {\r\n      this.state.defaultLanguage = routeData.sitecore.context.language;\r\n    }\r\n\r\n    // tell i18next to sync its current language with the route language\r\n    this.updateLanguage();\r\n  }\r\n\r\n  componentDidMount() {\r\n    const routeData = this.extractRouteData();\r\n\r\n    // if no existing routeData is present (from SSR), get Layout Service fetching the route data or ssr render complete\r\n    if (!routeData || this.props.ssrRenderComplete) {\r\n      this.updateRouteData();\r\n    }\r\n  }\r\n\r\n  extractRouteData = () => {\r\n    if (!this.props.sitecoreContext) return null;\r\n\r\n    const { route, ...context } = this.props.sitecoreContext;\r\n\r\n    return {\r\n      sitecore: {\r\n        route,\r\n        context,\r\n      },\r\n    };\r\n  };\r\n\r\n  /**\r\n   * Loads route data from Sitecore Layout Service into state.routeData\r\n   */\r\n  updateRouteData() {\r\n    let sitecoreRoutePath = this.props.route.match.params.sitecoreRoute || '/';\r\n    if (!sitecoreRoutePath.startsWith('/')) {\r\n      sitecoreRoutePath = `/${sitecoreRoutePath}`;\r\n    }\r\n\r\n    const language = this.props.route.match.params.lang || this.state.defaultLanguage;\r\n\r\n    // get the route data for the new route\r\n    getRouteData(sitecoreRoutePath, language).then((routeData) => {\r\n      if (routeData !== null && routeData.sitecore && routeData.sitecore.route) {\r\n        // set the sitecore context data and push the new route\r\n        this.props.updateSitecoreContext({\r\n          route: routeData.sitecore.route,\r\n          itemId: routeData.sitecore.route.itemId,\r\n          ...routeData.sitecore.context,\r\n        });\r\n        this.setState({ notFound: false });\r\n      } else {\r\n        this.setState({ notFound: true }, () => {\r\n          const context = routeData && routeData.sitecore ? routeData.sitecore.context : null;\r\n\r\n          this.props.updateSitecoreContext(context);\r\n        });\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Updates the current app language to match the route data.\r\n   */\r\n  updateLanguage() {\r\n    const newLanguage = this.props.route.match.params.lang || this.state.defaultLanguage;\r\n\r\n    if (i18n.language !== newLanguage) {\r\n      i18n.changeLanguage(newLanguage);\r\n    }\r\n  }\r\n\r\n  componentDidUpdate(previousProps) {\r\n    const existingRoute = previousProps.route.match.url;\r\n    const newRoute = this.props.route.match.url;\r\n\r\n    // don't change state (refetch route data) if the route has not changed\r\n    if (existingRoute === newRoute) {\r\n      return;\r\n    }\r\n\r\n    // if in experience editor - force reload instead of route data update\r\n    // avoids confusing Sitecore's editing JS\r\n    if (isExperienceEditorActive()) {\r\n      window.location.assign(newRoute);\r\n      return;\r\n    }\r\n\r\n    this.updateLanguage();\r\n    this.updateRouteData();\r\n  }\r\n\r\n  render() {\r\n    const { notFound } = this.state;\r\n    const routeData = this.extractRouteData();\r\n\r\n    // no route data for the current route in Sitecore - show not found component.\r\n    // Note: this is client-side only 404 handling. Server-side 404 handling is the responsibility\r\n    // of the server being used (i.e. node-headless-ssr-proxy and Sitecore intergrated rendering know how to send 404 status codes).\r\n    if (notFound && routeData) {\r\n      return (\r\n        <div>\r\n          <Helmet>\r\n            <title>{i18n.t('Page not found')}</title>\r\n          </Helmet>\r\n          <NotFound context={routeData.sitecore && routeData.sitecore.context} />\r\n        </div>\r\n      );\r\n    }\r\n\r\n    // Don't render anything if the route data or dictionary data is not fully loaded yet.\r\n    // This is a good place for a \"Loading\" component, if one is needed.\r\n    if (!routeData) {\r\n      return null;\r\n    }\r\n\r\n    // Render the app's root structural layout\r\n    return <Layout route={routeData.sitecore.route} />;\r\n  }\r\n}\r\n\r\n/**\r\n * Gets route data from Sitecore. This data is used to construct the component layout for a JSS route.\r\n * @param {string} route Route path to get data for (e.g. /about)\r\n * @param {string} language Language to get route data in (content language, e.g. 'en')\r\n */\r\nfunction getRouteData(route, language) {\r\n  const fetchOptions = {\r\n    layoutServiceConfig: { host: getHostname() },\r\n    querystringParams: { sc_lang: language, sc_apikey: config.sitecoreApiKey },\r\n    fetcher: dataFetcher,\r\n  };\r\n\r\n  return dataApi.fetchRouteData(route, fetchOptions).catch((error) => {\r\n    if (error.response && error.response.status === 404 && error.response.data) {\r\n      return error.response.data;\r\n    }\r\n\r\n    console.error('Route data fetch error', error, error.response);\r\n\r\n    return null;\r\n  });\r\n}\r\n\r\nexport default withSitecoreContext({ updatable: true })(RouteHandler);\r\n"]},"metadata":{},"sourceType":"module"}