{"ast":null,"code":"import { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nvar _jsxFileName = \"C:\\\\Users\\\\asha\\\\Documents\\\\ASHA\\\\sitecorejss\\\\test\\\\my-react-jss-app\\\\src\\\\index.js\";\nimport 'react-app-polyfill/ie11';\nimport 'react-app-polyfill/stable';\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { BrowserRouter } from 'react-router-dom';\nimport AppRoot from './AppRoot';\nimport GraphQLClientFactory from './lib/GraphQLClientFactory';\nimport config from './temp/config';\nimport i18ninit from './i18n';\n/* eslint-disable no-underscore-dangle */\n\nvar renderFunction = ReactDOM.render;\nvar initLanguage = config.defaultLanguage;\n/*\r\n  SSR Data\r\n  If we're running in a server-side rendering scenario,\r\n  the server will provide JSON in the #__JSS_STATE__ element\r\n  for us to acquire the initial state to run with on the client.\r\n\r\n  This enables us to skip a network request to load up the layout data.\r\n  We are emitting a quiescent script with JSON so that we can take advantage\r\n  of JSON.parse()'s speed advantage over parsing full JS, and enable\r\n  working without needing `unsafe-inline` in Content Security Policies.\r\n\r\n  SSR is initiated from /server/server.js.\r\n*/\n\nvar __JSS_STATE__ = null;\nvar ssrRawJson = document.getElementById('__JSS_STATE__');\n\nif (ssrRawJson) {\n  __JSS_STATE__ = JSON.parse(ssrRawJson.innerHTML);\n}\n\nif (__JSS_STATE__) {\n  // when React initializes from a SSR-based initial state, you need to render with `hydrate` instead of `render`\n  renderFunction = ReactDOM.hydrate; // set i18n language SSR state language instead of static config default language\n\n  initLanguage = __JSS_STATE__.sitecore.context.language;\n}\n/*\r\n  GraphQL Data\r\n  The Apollo Client needs to be initialized to make GraphQL available to the JSS app.\r\n  Not using GraphQL? Remove this, and the ApolloContext from `AppRoot`.\r\n*/\n// Apollo supports SSR of GraphQL queries, so like JSS SSR, it has an object we can pre-hydrate the client cache from\n// to avoid needing to re-run GraphQL queries after the SSR page loads\n\n\nvar initialGraphQLState = __JSS_STATE__ && __JSS_STATE__.APOLLO_STATE ? __JSS_STATE__.APOLLO_STATE : null;\nvar graphQLClient = GraphQLClientFactory(config.graphQLEndpoint, false, initialGraphQLState);\n/*\r\n  App Rendering\r\n*/\n// initialize the dictionary, then render the app\n// note: if not making a multlingual app, the dictionary init can be removed.\n\ni18ninit(initLanguage).then(() => {\n  // HTML element to place the app into\n  var rootElement = document.getElementById('root');\n  renderFunction( /*#__PURE__*/_jsxDEV(AppRoot, {\n    path: window.location.pathname,\n    Router: BrowserRouter,\n    graphQLClient: graphQLClient,\n    ssrState: __JSS_STATE__\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 66,\n    columnNumber: 5\n  }, this), rootElement);\n});","map":{"version":3,"sources":["C:/Users/asha/Documents/ASHA/sitecorejss/test/my-react-jss-app/src/index.js"],"names":["React","ReactDOM","BrowserRouter","AppRoot","GraphQLClientFactory","config","i18ninit","renderFunction","render","initLanguage","defaultLanguage","__JSS_STATE__","ssrRawJson","document","getElementById","JSON","parse","innerHTML","hydrate","sitecore","context","language","initialGraphQLState","APOLLO_STATE","graphQLClient","graphQLEndpoint","then","rootElement","window","location","pathname"],"mappings":";;AAAA,OAAO,yBAAP;AACA,OAAO,2BAAP;AAEA,OAAOA,KAAP,MAAkB,OAAlB;AACA,OAAOC,QAAP,MAAqB,WAArB;AACA,SAASC,aAAT,QAA8B,kBAA9B;AACA,OAAOC,OAAP,MAAoB,WAApB;AACA,OAAOC,oBAAP,MAAiC,4BAAjC;AACA,OAAOC,MAAP,MAAmB,eAAnB;AACA,OAAOC,QAAP,MAAqB,QAArB;AAEA;;AAEA,IAAIC,cAAc,GAAGN,QAAQ,CAACO,MAA9B;AAEA,IAAIC,YAAY,GAAGJ,MAAM,CAACK,eAA1B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAIC,aAAa,GAAG,IAApB;AACA,IAAMC,UAAU,GAAGC,QAAQ,CAACC,cAAT,CAAwB,eAAxB,CAAnB;;AACA,IAAIF,UAAJ,EAAgB;AACdD,EAAAA,aAAa,GAAGI,IAAI,CAACC,KAAL,CAAWJ,UAAU,CAACK,SAAtB,CAAhB;AACD;;AACD,IAAIN,aAAJ,EAAmB;AACjB;AACAJ,EAAAA,cAAc,GAAGN,QAAQ,CAACiB,OAA1B,CAFiB,CAIjB;;AACAT,EAAAA,YAAY,GAAGE,aAAa,CAACQ,QAAd,CAAuBC,OAAvB,CAA+BC,QAA9C;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAMC,mBAAmB,GACvBX,aAAa,IAAIA,aAAa,CAACY,YAA/B,GAA8CZ,aAAa,CAACY,YAA5D,GAA2E,IAD7E;AAGA,IAAMC,aAAa,GAAGpB,oBAAoB,CAACC,MAAM,CAACoB,eAAR,EAAyB,KAAzB,EAAgCH,mBAAhC,CAA1C;AAEA;AACA;AACA;AACA;AACA;;AACAhB,QAAQ,CAACG,YAAD,CAAR,CAAuBiB,IAAvB,CAA4B,MAAM;AAChC;AACA,MAAMC,WAAW,GAAGd,QAAQ,CAACC,cAAT,CAAwB,MAAxB,CAApB;AAEAP,EAAAA,cAAc,eACZ,QAAC,OAAD;AACE,IAAA,IAAI,EAAEqB,MAAM,CAACC,QAAP,CAAgBC,QADxB;AAEE,IAAA,MAAM,EAAE5B,aAFV;AAGE,IAAA,aAAa,EAAEsB,aAHjB;AAIE,IAAA,QAAQ,EAAEb;AAJZ;AAAA;AAAA;AAAA;AAAA,UADY,EAOZgB,WAPY,CAAd;AASD,CAbD","sourcesContent":["import 'react-app-polyfill/ie11';\r\nimport 'react-app-polyfill/stable';\r\n\r\nimport React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport { BrowserRouter } from 'react-router-dom';\r\nimport AppRoot from './AppRoot';\r\nimport GraphQLClientFactory from './lib/GraphQLClientFactory';\r\nimport config from './temp/config';\r\nimport i18ninit from './i18n';\r\n\r\n/* eslint-disable no-underscore-dangle */\r\n\r\nlet renderFunction = ReactDOM.render;\r\n\r\nlet initLanguage = config.defaultLanguage;\r\n\r\n/*\r\n  SSR Data\r\n  If we're running in a server-side rendering scenario,\r\n  the server will provide JSON in the #__JSS_STATE__ element\r\n  for us to acquire the initial state to run with on the client.\r\n\r\n  This enables us to skip a network request to load up the layout data.\r\n  We are emitting a quiescent script with JSON so that we can take advantage\r\n  of JSON.parse()'s speed advantage over parsing full JS, and enable\r\n  working without needing `unsafe-inline` in Content Security Policies.\r\n\r\n  SSR is initiated from /server/server.js.\r\n*/\r\nlet __JSS_STATE__ = null;\r\nconst ssrRawJson = document.getElementById('__JSS_STATE__');\r\nif (ssrRawJson) {\r\n  __JSS_STATE__ = JSON.parse(ssrRawJson.innerHTML);\r\n}\r\nif (__JSS_STATE__) {\r\n  // when React initializes from a SSR-based initial state, you need to render with `hydrate` instead of `render`\r\n  renderFunction = ReactDOM.hydrate;\r\n\r\n  // set i18n language SSR state language instead of static config default language\r\n  initLanguage = __JSS_STATE__.sitecore.context.language;\r\n}\r\n\r\n/*\r\n  GraphQL Data\r\n  The Apollo Client needs to be initialized to make GraphQL available to the JSS app.\r\n  Not using GraphQL? Remove this, and the ApolloContext from `AppRoot`.\r\n*/\r\n// Apollo supports SSR of GraphQL queries, so like JSS SSR, it has an object we can pre-hydrate the client cache from\r\n// to avoid needing to re-run GraphQL queries after the SSR page loads\r\nconst initialGraphQLState =\r\n  __JSS_STATE__ && __JSS_STATE__.APOLLO_STATE ? __JSS_STATE__.APOLLO_STATE : null;\r\n\r\nconst graphQLClient = GraphQLClientFactory(config.graphQLEndpoint, false, initialGraphQLState);\r\n\r\n/*\r\n  App Rendering\r\n*/\r\n// initialize the dictionary, then render the app\r\n// note: if not making a multlingual app, the dictionary init can be removed.\r\ni18ninit(initLanguage).then(() => {\r\n  // HTML element to place the app into\r\n  const rootElement = document.getElementById('root');\r\n\r\n  renderFunction(\r\n    <AppRoot\r\n      path={window.location.pathname}\r\n      Router={BrowserRouter}\r\n      graphQLClient={graphQLClient}\r\n      ssrState={__JSS_STATE__}\r\n    />,\r\n    rootElement\r\n  );\r\n});\r\n"]},"metadata":{},"sourceType":"module"}