{"ast":null,"code":"import { __extends, __rest, __assign } from 'tslib';\nimport { ApolloLink, fromError, Observable } from 'apollo-link';\nimport { checkFetcher, selectURI, selectHttpOptionsAndBody, fallbackHttpConfig, serializeFetchParameter, createSignalIfSupported, parseAndCheckHttpResponse } from 'apollo-link-http-common';\nimport { BatchLink } from 'apollo-link-batch';\n\nvar BatchHttpLink = function (_super) {\n  __extends(BatchHttpLink, _super);\n\n  function BatchHttpLink(fetchParams) {\n    var _this = _super.call(this) || this;\n\n    var _a = fetchParams || {},\n        _b = _a.uri,\n        uri = _b === void 0 ? '/graphql' : _b,\n        fetcher = _a.fetch,\n        includeExtensions = _a.includeExtensions,\n        batchInterval = _a.batchInterval,\n        batchMax = _a.batchMax,\n        batchKey = _a.batchKey,\n        requestOptions = __rest(_a, [\"uri\", \"fetch\", \"includeExtensions\", \"batchInterval\", \"batchMax\", \"batchKey\"]);\n\n    checkFetcher(fetcher);\n\n    if (!fetcher) {\n      fetcher = fetch;\n    }\n\n    var linkConfig = {\n      http: {\n        includeExtensions: includeExtensions\n      },\n      options: requestOptions.fetchOptions,\n      credentials: requestOptions.credentials,\n      headers: requestOptions.headers\n    };\n    _this.batchInterval = batchInterval || 10;\n    _this.batchMax = batchMax || 10;\n\n    var batchHandler = function batchHandler(operations) {\n      var chosenURI = selectURI(operations[0], uri);\n      var context = operations[0].getContext();\n      var clientAwarenessHeaders = {};\n\n      if (context.clientAwareness) {\n        var _a = context.clientAwareness,\n            name_1 = _a.name,\n            version = _a.version;\n\n        if (name_1) {\n          clientAwarenessHeaders['apollographql-client-name'] = name_1;\n        }\n\n        if (version) {\n          clientAwarenessHeaders['apollographql-client-version'] = version;\n        }\n      }\n\n      var contextConfig = {\n        http: context.http,\n        options: context.fetchOptions,\n        credentials: context.credentials,\n        headers: __assign({}, clientAwarenessHeaders, context.headers)\n      };\n      var optsAndBody = operations.map(function (operation) {\n        return selectHttpOptionsAndBody(operation, fallbackHttpConfig, linkConfig, contextConfig);\n      });\n      var loadedBody = optsAndBody.map(function (_a) {\n        var body = _a.body;\n        return body;\n      });\n      var options = optsAndBody[0].options;\n\n      if (options.method === 'GET') {\n        return fromError(new Error('apollo-link-batch-http does not support GET requests'));\n      }\n\n      try {\n        options.body = serializeFetchParameter(loadedBody, 'Payload');\n      } catch (parseError) {\n        return fromError(parseError);\n      }\n\n      var controller;\n\n      if (!options.signal) {\n        var _b = createSignalIfSupported(),\n            _controller = _b.controller,\n            signal = _b.signal;\n\n        controller = _controller;\n        if (controller) options.signal = signal;\n      }\n\n      return new Observable(function (observer) {\n        fetcher(chosenURI, options).then(function (response) {\n          operations.forEach(function (operation) {\n            return operation.setContext({\n              response: response\n            });\n          });\n          return response;\n        }).then(parseAndCheckHttpResponse(operations)).then(function (result) {\n          observer.next(result);\n          observer.complete();\n          return result;\n        }).catch(function (err) {\n          if (err.name === 'AbortError') return;\n\n          if (err.result && err.result.errors && err.result.data) {\n            observer.next(err.result);\n          }\n\n          observer.error(err);\n        });\n        return function () {\n          if (controller) controller.abort();\n        };\n      });\n    };\n\n    batchKey = batchKey || function (operation) {\n      var context = operation.getContext();\n      var contextConfig = {\n        http: context.http,\n        options: context.fetchOptions,\n        credentials: context.credentials,\n        headers: context.headers\n      };\n      return selectURI(operation, uri) + JSON.stringify(contextConfig);\n    };\n\n    _this.batcher = new BatchLink({\n      batchInterval: _this.batchInterval,\n      batchMax: _this.batchMax,\n      batchKey: batchKey,\n      batchHandler: batchHandler\n    });\n    return _this;\n  }\n\n  BatchHttpLink.prototype.request = function (operation) {\n    return this.batcher.request(operation);\n  };\n\n  return BatchHttpLink;\n}(ApolloLink);\n\nexport { BatchHttpLink };","map":{"version":3,"sources":["../src/batchHttpLink.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  ApolloLink,\n  Operation,\n  FetchResult,\n  Observable,\n  fromError,\n} from 'apollo-link';\nimport {\n  serializeFetchParameter,\n  selectURI,\n  parseAndCheckHttpResponse,\n  checkFetcher,\n  selectHttpOptionsAndBody,\n  createSignalIfSupported,\n  fallbackHttpConfig,\n  HttpOptions,\n} from 'apollo-link-http-common';\nimport { BatchLink } from 'apollo-link-batch';\n\nexport namespace BatchHttpLink {\n  export interface Options extends HttpOptions {\n    /**\n     * The maximum number of operations to include in one fetch.\n     *\n     * Defaults to 10.\n     */\n    batchMax?: number;\n\n    /**\n     * The interval at which to batch, in milliseconds.\n     *\n     * Defaults to 10.\n     */\n    batchInterval?: number;\n\n    /**\n     * Sets the key for an Operation, which specifies the batch an operation is included in\n     */\n    batchKey?: (operation: Operation) => string;\n  }\n}\n\n/**\n * Transforms Operation for into HTTP results.\n * context can include the headers property, which will be passed to the fetch function\n */\nexport class BatchHttpLink extends ApolloLink {\n  private batchInterval: number;\n  private batchMax: number;\n  private batcher: ApolloLink;\n\n  constructor(fetchParams?: BatchHttpLink.Options) {\n    super();\n\n    let {\n      uri = '/graphql',\n      // use default global fetch if nothing is passed in\n      fetch: fetcher,\n      includeExtensions,\n      batchInterval,\n      batchMax,\n      batchKey,\n      ...requestOptions\n    } = fetchParams || ({} as BatchHttpLink.Options);\n\n    // dev warnings to ensure fetch is present\n    checkFetcher(fetcher);\n\n    //fetcher is set here rather than the destructuring to ensure fetch is\n    //declared before referencing it. Reference in the destructuring would cause\n    //a ReferenceError\n    if (!fetcher) {\n      fetcher = fetch;\n    }\n\n    const linkConfig = {\n      http: { includeExtensions },\n      options: requestOptions.fetchOptions,\n      credentials: requestOptions.credentials,\n      headers: requestOptions.headers,\n    };\n\n    this.batchInterval = batchInterval || 10;\n    this.batchMax = batchMax || 10;\n\n    const batchHandler = (operations: Operation[]) => {\n      const chosenURI = selectURI(operations[0], uri);\n\n      const context = operations[0].getContext();\n\n      const clientAwarenessHeaders = {};\n      if (context.clientAwareness) {\n        const { name, version } = context.clientAwareness;\n        if (name) {\n          clientAwarenessHeaders['apollographql-client-name'] = name;\n        }\n        if (version) {\n          clientAwarenessHeaders['apollographql-client-version'] = version;\n        }\n      }\n\n      const contextConfig = {\n        http: context.http,\n        options: context.fetchOptions,\n        credentials: context.credentials,\n        headers: { ...clientAwarenessHeaders, ...context.headers },\n      };\n\n      //uses fallback, link, and then context to build options\n      const optsAndBody = operations.map(operation =>\n        selectHttpOptionsAndBody(\n          operation,\n          fallbackHttpConfig,\n          linkConfig,\n          contextConfig,\n        ),\n      );\n\n      const loadedBody = optsAndBody.map(({ body }) => body);\n      const options = optsAndBody[0].options;\n\n      // There's no spec for using GET with batches.\n      if (options.method === 'GET') {\n        return fromError<FetchResult[]>(\n          new Error('apollo-link-batch-http does not support GET requests'),\n        );\n      }\n\n      try {\n        (options as any).body = serializeFetchParameter(loadedBody, 'Payload');\n      } catch (parseError) {\n        return fromError<FetchResult[]>(parseError);\n      }\n\n      let controller;\n      if (!(options as any).signal) {\n        const { controller: _controller, signal } = createSignalIfSupported();\n        controller = _controller;\n        if (controller) (options as any).signal = signal;\n      }\n\n      return new Observable<FetchResult[]>(observer => {\n        fetcher(chosenURI, options)\n          .then(response => {\n            // Make the raw response available in the context.\n            operations.forEach(operation => operation.setContext({ response }));\n            return response;\n          })\n          .then(parseAndCheckHttpResponse(operations))\n          .then(result => {\n            // we have data and can send it to back up the link chain\n            observer.next(result);\n            observer.complete();\n            return result;\n          })\n          .catch(err => {\n            // fetch was cancelled so its already been cleaned up in the unsubscribe\n            if (err.name === 'AbortError') return;\n            // if it is a network error, BUT there is graphql result info\n            // fire the next observer before calling error\n            // this gives apollo-client (and react-apollo) the `graphqlErrors` and `networErrors`\n            // to pass to UI\n            // this should only happen if we *also* have data as part of the response key per\n            // the spec\n            if (err.result && err.result.errors && err.result.data) {\n              // if we dont' call next, the UI can only show networkError because AC didn't\n              // get andy graphqlErrors\n              // this is graphql execution result info (i.e errors and possibly data)\n              // this is because there is no formal spec how errors should translate to\n              // http status codes. So an auth error (401) could have both data\n              // from a public field, errors from a private field, and a status of 401\n              // {\n              //  user { // this will have errors\n              //    firstName\n              //  }\n              //  products { // this is public so will have data\n              //    cost\n              //  }\n              // }\n              //\n              // the result of above *could* look like this:\n              // {\n              //   data: { products: [{ cost: \"$10\" }] },\n              //   errors: [{\n              //      message: 'your session has timed out',\n              //      path: []\n              //   }]\n              // }\n              // status code of above would be a 401\n              // in the UI you want to show data where you can, errors as data where you can\n              // and use correct http status codes\n              observer.next(err.result);\n            }\n\n            observer.error(err);\n          });\n\n        return () => {\n          // XXX support canceling this request\n          // https://developers.google.com/web/updates/2017/09/abortable-fetch\n          if (controller) controller.abort();\n        };\n      });\n    };\n\n    batchKey =\n      batchKey ||\n      ((operation: Operation) => {\n        const context = operation.getContext();\n\n        const contextConfig = {\n          http: context.http,\n          options: context.fetchOptions,\n          credentials: context.credentials,\n          headers: context.headers,\n        };\n\n        //may throw error if config not serializable\n        return selectURI(operation, uri) + JSON.stringify(contextConfig);\n      });\n\n    this.batcher = new BatchLink({\n      batchInterval: this.batchInterval,\n      batchMax: this.batchMax,\n      batchKey,\n      batchHandler,\n    });\n  }\n\n  public request(operation: Operation): Observable<FetchResult> | null {\n    return this.batcher.request(operation);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}