{"ast":null,"code":"import { __assign, __extends } from 'tslib';\nimport { Observable, ApolloLink } from 'apollo-link';\n\nvar OperationBatcher = function () {\n  function OperationBatcher(_a) {\n    var batchInterval = _a.batchInterval,\n        batchMax = _a.batchMax,\n        batchHandler = _a.batchHandler,\n        batchKey = _a.batchKey;\n    this.queuedRequests = new Map();\n    this.batchInterval = batchInterval;\n    this.batchMax = batchMax || 0;\n    this.batchHandler = batchHandler;\n\n    this.batchKey = batchKey || function () {\n      return '';\n    };\n  }\n\n  OperationBatcher.prototype.enqueueRequest = function (request) {\n    var _this = this;\n\n    var requestCopy = __assign({}, request);\n\n    var queued = false;\n    var key = this.batchKey(request.operation);\n\n    if (!requestCopy.observable) {\n      requestCopy.observable = new Observable(function (observer) {\n        if (!_this.queuedRequests.has(key)) {\n          _this.queuedRequests.set(key, []);\n        }\n\n        if (!queued) {\n          _this.queuedRequests.get(key).push(requestCopy);\n\n          queued = true;\n        }\n\n        requestCopy.next = requestCopy.next || [];\n        if (observer.next) requestCopy.next.push(observer.next.bind(observer));\n        requestCopy.error = requestCopy.error || [];\n        if (observer.error) requestCopy.error.push(observer.error.bind(observer));\n        requestCopy.complete = requestCopy.complete || [];\n        if (observer.complete) requestCopy.complete.push(observer.complete.bind(observer));\n\n        if (_this.queuedRequests.get(key).length === 1) {\n          _this.scheduleQueueConsumption(key);\n        }\n\n        if (_this.queuedRequests.get(key).length === _this.batchMax) {\n          _this.consumeQueue(key);\n        }\n      });\n    }\n\n    return requestCopy.observable;\n  };\n\n  OperationBatcher.prototype.consumeQueue = function (key) {\n    var requestKey = key || '';\n    var queuedRequests = this.queuedRequests.get(requestKey);\n\n    if (!queuedRequests) {\n      return;\n    }\n\n    this.queuedRequests.delete(requestKey);\n    var requests = queuedRequests.map(function (queuedRequest) {\n      return queuedRequest.operation;\n    });\n    var forwards = queuedRequests.map(function (queuedRequest) {\n      return queuedRequest.forward;\n    });\n    var observables = [];\n    var nexts = [];\n    var errors = [];\n    var completes = [];\n    queuedRequests.forEach(function (batchableRequest, index) {\n      observables.push(batchableRequest.observable);\n      nexts.push(batchableRequest.next);\n      errors.push(batchableRequest.error);\n      completes.push(batchableRequest.complete);\n    });\n    var batchedObservable = this.batchHandler(requests, forwards) || Observable.of();\n\n    var onError = function onError(error) {\n      errors.forEach(function (rejecters) {\n        if (rejecters) {\n          rejecters.forEach(function (e) {\n            return e(error);\n          });\n        }\n      });\n    };\n\n    batchedObservable.subscribe({\n      next: function next(results) {\n        if (!Array.isArray(results)) {\n          results = [results];\n        }\n\n        if (nexts.length !== results.length) {\n          var error = new Error(\"server returned results with length \" + results.length + \", expected length of \" + nexts.length);\n          error.result = results;\n          return onError(error);\n        }\n\n        results.forEach(function (result, index) {\n          if (nexts[index]) {\n            nexts[index].forEach(function (next) {\n              return next(result);\n            });\n          }\n        });\n      },\n      error: onError,\n      complete: function complete() {\n        completes.forEach(function (complete) {\n          if (complete) {\n            complete.forEach(function (c) {\n              return c();\n            });\n          }\n        });\n      }\n    });\n    return observables;\n  };\n\n  OperationBatcher.prototype.scheduleQueueConsumption = function (key) {\n    var _this = this;\n\n    var requestKey = key || '';\n    setTimeout(function () {\n      if (_this.queuedRequests.get(requestKey) && _this.queuedRequests.get(requestKey).length) {\n        _this.consumeQueue(requestKey);\n      }\n    }, this.batchInterval);\n  };\n\n  return OperationBatcher;\n}();\n\nvar BatchLink = function (_super) {\n  __extends(BatchLink, _super);\n\n  function BatchLink(fetchParams) {\n    var _this = _super.call(this) || this;\n\n    var _a = fetchParams || {},\n        _b = _a.batchInterval,\n        batchInterval = _b === void 0 ? 10 : _b,\n        _c = _a.batchMax,\n        batchMax = _c === void 0 ? 0 : _c,\n        _d = _a.batchHandler,\n        batchHandler = _d === void 0 ? function () {\n      return null;\n    } : _d,\n        _e = _a.batchKey,\n        batchKey = _e === void 0 ? function () {\n      return '';\n    } : _e;\n\n    _this.batcher = new OperationBatcher({\n      batchInterval: batchInterval,\n      batchMax: batchMax,\n      batchHandler: batchHandler,\n      batchKey: batchKey\n    });\n\n    if (fetchParams.batchHandler.length <= 1) {\n      _this.request = function (operation) {\n        return _this.batcher.enqueueRequest({\n          operation: operation\n        });\n      };\n    }\n\n    return _this;\n  }\n\n  BatchLink.prototype.request = function (operation, forward) {\n    return this.batcher.enqueueRequest({\n      operation: operation,\n      forward: forward\n    });\n  };\n\n  return BatchLink;\n}(ApolloLink);\n\nexport { BatchLink, OperationBatcher };","map":{"version":3,"sources":["../src/batching.ts","../src/batchLink.ts"],"names":[],"mappings":"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","sourcesContent":["import { Observable, Operation, NextLink, FetchResult } from 'apollo-link';\n\nexport type BatchHandler = (\n  operations: Operation[],\n  forward?: (NextLink | undefined)[],\n) => Observable<FetchResult[]> | null;\n\nexport interface BatchableRequest {\n  operation: Operation;\n  forward?: NextLink;\n\n  // promise is created when the query fetch request is\n  // added to the queue and is resolved once the result is back\n  // from the server.\n  observable?: Observable<FetchResult>;\n  next?: Array<(result: FetchResult) => void>;\n  error?: Array<(error: Error) => void>;\n  complete?: Array<() => void>;\n}\n\n// QueryBatcher doesn't fire requests immediately. Requests that were enqueued within\n// a certain amount of time (configurable through `batchInterval`) will be batched together\n// into one query.\nexport class OperationBatcher {\n  // Queue on which the QueryBatcher will operate on a per-tick basis.\n  // Public only for testing\n  public queuedRequests: Map<string, BatchableRequest[]>;\n\n  private batchInterval: number;\n  private batchMax: number;\n\n  //This function is called to the queries in the queue to the server.\n  private batchHandler: BatchHandler;\n  private batchKey: (operation: Operation) => string;\n\n  constructor({\n    batchInterval,\n    batchMax,\n    batchHandler,\n    batchKey,\n  }: {\n    batchInterval?: number;\n    batchMax?: number;\n    batchHandler: BatchHandler;\n    batchKey?: (operation: Operation) => string;\n  }) {\n    this.queuedRequests = new Map();\n    this.batchInterval = batchInterval;\n    this.batchMax = batchMax || 0;\n    this.batchHandler = batchHandler;\n    this.batchKey = batchKey || (() => '');\n  }\n\n  public enqueueRequest(request: BatchableRequest): Observable<FetchResult> {\n    const requestCopy = {\n      ...request,\n    };\n    let queued = false;\n\n    const key = this.batchKey(request.operation);\n\n    if (!requestCopy.observable) {\n      requestCopy.observable = new Observable<FetchResult>(observer => {\n        if (!this.queuedRequests.has(key)) {\n          this.queuedRequests.set(key, []);\n        }\n\n        if (!queued) {\n          this.queuedRequests.get(key).push(requestCopy);\n          queued = true;\n        }\n\n        //called for each subscriber, so need to save all listeners(next, error, complete)\n        requestCopy.next = requestCopy.next || [];\n        if (observer.next) requestCopy.next.push(observer.next.bind(observer));\n\n        requestCopy.error = requestCopy.error || [];\n        if (observer.error)\n          requestCopy.error.push(observer.error.bind(observer));\n\n        requestCopy.complete = requestCopy.complete || [];\n        if (observer.complete)\n          requestCopy.complete.push(observer.complete.bind(observer));\n\n        // The first enqueued request triggers the queue consumption after `batchInterval` milliseconds.\n        if (this.queuedRequests.get(key).length === 1) {\n          this.scheduleQueueConsumption(key);\n        }\n\n        // When amount of requests reaches `batchMax`, trigger the queue consumption without waiting on the `batchInterval`.\n        if (this.queuedRequests.get(key).length === this.batchMax) {\n          this.consumeQueue(key);\n        }\n      });\n    }\n\n    return requestCopy.observable;\n  }\n\n  // Consumes the queue.\n  // Returns a list of promises (one for each query).\n  public consumeQueue(\n    key?: string,\n  ): (Observable<FetchResult> | undefined)[] | undefined {\n    const requestKey = key || '';\n    const queuedRequests = this.queuedRequests.get(requestKey);\n\n    if (!queuedRequests) {\n      return;\n    }\n\n    this.queuedRequests.delete(requestKey);\n\n    const requests: Operation[] = queuedRequests.map(\n      queuedRequest => queuedRequest.operation,\n    );\n\n    const forwards: NextLink[] = queuedRequests.map(\n      queuedRequest => queuedRequest.forward,\n    );\n\n    const observables: (Observable<FetchResult> | undefined)[] = [];\n    const nexts: any[] = [];\n    const errors: any[] = [];\n    const completes: any[] = [];\n    queuedRequests.forEach((batchableRequest, index) => {\n      observables.push(batchableRequest.observable);\n      nexts.push(batchableRequest.next);\n      errors.push(batchableRequest.error);\n      completes.push(batchableRequest.complete);\n    });\n\n    const batchedObservable =\n      this.batchHandler(requests, forwards) || Observable.of();\n\n    const onError = error => {\n      //each callback list in batch\n      errors.forEach(rejecters => {\n        if (rejecters) {\n          //each subscriber to request\n          rejecters.forEach(e => e(error));\n        }\n      });\n    };\n\n    batchedObservable.subscribe({\n      next: results => {\n        if (!Array.isArray(results)) {\n          results = [results];\n        }\n\n        if (nexts.length !== results.length) {\n          const error = new Error(\n            `server returned results with length ${\n              results.length\n            }, expected length of ${nexts.length}`,\n          );\n          (error as any).result = results;\n\n          return onError(error);\n        }\n\n        results.forEach((result, index) => {\n          if (nexts[index]) {\n            nexts[index].forEach(next => next(result));\n          }\n        });\n      },\n      error: onError,\n      complete: () => {\n        completes.forEach(complete => {\n          if (complete) {\n            //each subscriber to request\n            complete.forEach(c => c());\n          }\n        });\n      },\n    });\n\n    return observables;\n  }\n\n  private scheduleQueueConsumption(key?: string): void {\n    const requestKey = key || '';\n    setTimeout(() => {\n      if (\n        this.queuedRequests.get(requestKey) &&\n        this.queuedRequests.get(requestKey).length\n      ) {\n        this.consumeQueue(requestKey);\n      }\n    }, this.batchInterval);\n  }\n}\n","import {\n  ApolloLink,\n  Operation,\n  FetchResult,\n  Observable,\n  NextLink,\n} from 'apollo-link';\nimport { OperationBatcher, BatchHandler } from './batching';\n\nexport { OperationBatcher, BatchableRequest, BatchHandler } from './batching';\n\nexport namespace BatchLink {\n  export interface Options {\n    /**\n     * The interval at which to batch, in milliseconds.\n     *\n     * Defaults to 10.\n     */\n    batchInterval?: number;\n\n    /**\n     * The maximum number of operations to include in one fetch.\n     *\n     * Defaults to 0 (infinite operations within the interval).\n     */\n    batchMax?: number;\n\n    /**\n     * The handler that should execute a batch of operations.\n     */\n    batchHandler?: BatchHandler;\n\n    /**\n     * creates the key for a batch\n     */\n    batchKey?: (operation: Operation) => string;\n  }\n}\n\nexport class BatchLink extends ApolloLink {\n  private batcher: OperationBatcher;\n\n  constructor(fetchParams?: BatchLink.Options) {\n    super();\n\n    const {\n      batchInterval = 10,\n      batchMax = 0,\n      batchHandler = () => null,\n      batchKey = () => '',\n    } = fetchParams || {};\n\n    this.batcher = new OperationBatcher({\n      batchInterval,\n      batchMax,\n      batchHandler,\n      batchKey,\n    });\n\n    //make this link terminating\n    if (fetchParams.batchHandler.length <= 1) {\n      this.request = operation => this.batcher.enqueueRequest({ operation });\n    }\n  }\n\n  public request(\n    operation: Operation,\n    forward?: NextLink,\n  ): Observable<FetchResult> | null {\n    return this.batcher.enqueueRequest({\n      operation,\n      forward,\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}