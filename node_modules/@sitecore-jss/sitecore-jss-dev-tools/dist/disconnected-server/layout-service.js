"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createDisconnectedLayoutService = exports.remapFieldsArrayToFieldsObject = void 0;
var chalk_1 = __importDefault(require("chalk"));
/**
 * Implements a fake version of the Sitecore JSS Layout Service that is powered by a local manifest file
 * @param {string} language
 */
function createDefaultContext(language) {
    return {
        pageEditing: false,
        site: {
            name: 'JssDisconnectedLayoutService',
        },
        pageState: 'normal',
        language: language,
    };
}
/**
 * @param {string} routePath
 * @param {ManifestInstance} manifest
 */
function getRouteData(routePath, manifest) {
    var pathBits = routePath.split('/').filter(function (bit) { return bit && bit.length > 0; });
    if (!pathBits) {
        return null;
    }
    // the home route is the first defined root route
    var homeRoute = manifest.items.routes[0];
    // no length = a request for "/", so we send the home route
    if (pathBits.length === 0) {
        return homeRoute;
    }
    if (!homeRoute.children) {
        return null;
    }
    // traverse the route tree searching for a matching route
    var currentRoute = homeRoute.children.find(function (route) { return route.name.toUpperCase() === pathBits[0].toUpperCase(); });
    var _loop_1 = function (segment) {
        if (!currentRoute || !currentRoute.children) {
            return { value: null };
        }
        currentRoute = currentRoute.children.find(function (route) { return route.name.toUpperCase() === pathBits[segment].toUpperCase(); });
    };
    for (var segment = 1; segment < pathBits.length; segment += 1) {
        var state_1 = _loop_1(segment);
        if (typeof state_1 === "object")
            return state_1.value;
    }
    if (!currentRoute) {
        return null;
    }
    return currentRoute;
}
/**
 * @param {string} dynamicKey
 */
function extractDynamicPlaceholderKeyDetails(dynamicKey) {
    // attempts to match a dynamic placeholder key of the format (key)-{UID}-{index}, e.g. page-content-{BC8C7AB9-6D40-5393-ABDE-6D7DF27F2D3F}-0
    var dynamicKeyMatches = /^(.*)-(\{{0,1}([0-9a-fA-F]){8}-([0-9a-fA-F]){4}-([0-9a-fA-F]){4}-([0-9a-fA-F]){4}-([0-9a-fA-F]){12}\}{0,1})-([0-9]+)$/.exec(dynamicKey);
    // non-dynamic placeholder name (e.g. 'main') if fails the regex
    if (dynamicKeyMatches === null) {
        return { name: dynamicKey, segment: dynamicKey };
    }
    if (dynamicKeyMatches.length < 3) {
        throw new Error("Unable to match dynamic placeholder key " + dynamicKey + "; did not match Sitecore format [key]-GUID-index.");
    }
    return {
        name: dynamicKeyMatches[1],
        uid: dynamicKeyMatches[2],
        index: dynamicKeyMatches[3],
        segment: dynamicKey,
    };
}
/**
 * @param {string} placeholderKey
 */
function extractTopLevelPlaceholderDetails(placeholderKey) {
    var keySegment = placeholderKey;
    if (!placeholderKey) {
        return null;
    }
    // strip any leading /
    if (keySegment.indexOf('/') === 0) {
        keySegment = keySegment.substring(1);
    }
    var separatorIndex = keySegment.indexOf('/');
    // multipart placeholder (e.g. /main/foo/bar)
    if (separatorIndex >= 0) {
        return extractDynamicPlaceholderKeyDetails(keySegment.substring(0, separatorIndex));
    }
    // single part placeholder (e.g. 'main')
    return extractDynamicPlaceholderKeyDetails(keySegment);
}
/**
 * @param {string} placeholderKey
 * @param {any} resultObject
 */
function getOrCreatePlaceholderPath(placeholderKey, resultObject) {
    var placeholderDetails = extractTopLevelPlaceholderDetails(placeholderKey);
    if (placeholderDetails === null) {
        throw new Error("No placeholder could be resolved from key " + placeholderKey);
    }
    var placeholder;
    // NOTE: the resultObject is an object for a singular placeholder name (the root 'placeholders' object)
    // but it is an array for a dynamic placeholder (the parent placeholder's renderings array)
    if (placeholderDetails.uid) {
        // resolve dynamic placeholder
        var dynamicParent = resultObject.find(function (rendering) { return rendering.uid === placeholderDetails.uid; });
        if (!dynamicParent) {
            throw new Error("The rendering UID referenced in the placeholder " + placeholderKey + " was not defined in the layout definition.");
        }
        if (!dynamicParent.placeholders) {
            dynamicParent.placeholders = {};
        }
        if (!dynamicParent.placeholders[placeholderDetails.name]) {
            dynamicParent.placeholders[placeholderDetails.name] = [];
        }
        placeholder = dynamicParent.placeholders[placeholderDetails.name];
    }
    else {
        // resolve singular placeholder name
        placeholder = resultObject[placeholderDetails.name];
        if (!placeholder) {
            // eslint-disable-next-line no-multi-assign, no-param-reassign
            placeholder = resultObject[placeholderDetails.name] = [];
        }
    }
    // check if we have more placeholders to traverse
    // using length + 1 to account for a leading / in the ph key (e.g. /main vs segment main)
    if (placeholderKey.length > placeholderDetails.segment.length + 1) {
        return getOrCreatePlaceholderPath(
        // length + 2 accounts for leading /
        placeholderKey.substring(placeholderDetails.segment.length + 1), placeholder);
    }
    return placeholder;
}
/**
 * @param {any} input
 */
function remapFieldsArrayToFieldsObject(input) {
    // fields go from "name: foo, value: bar" to "foo: { value: bar, editable: bar }"
    return input.reduce(function (fieldReduceResult, current) {
        var value = current.value;
        // blacklist properties that can be in manifest data but are not in LS data
        delete value.displayName;
        delete value.name;
        delete value.template;
        delete value.resolvedFromItemId;
        // array value is an item definition; in which case we also need to remap that item's fields
        if (Array.isArray(value) && value.length > 0 && value[0].fields) {
            value = value.map(function (field) {
                var itemResult = __assign(__assign({}, field), { fields: remapFieldsArrayToFieldsObject(field.fields) });
                // add a faux ID to content lists to match LS
                if (!itemResult.id) {
                    itemResult.id = 'available-in-connected-mode';
                }
                // blacklist properties that can be in manifest data but are not in LS data
                delete itemResult.displayName;
                delete itemResult.name;
                delete itemResult.template;
                delete itemResult.resolvedFromItemId;
                return itemResult;
            });
            fieldReduceResult[current.name] = value;
            return fieldReduceResult;
        }
        // field value is a singular item (i.e. an Item Link/Droptree)
        // we need to remap those field values too
        if (value && value.fields && Array.isArray(value.fields)) {
            fieldReduceResult[current.name] = __assign(__assign({ 
                // add faux ID to item links to match LS
                id: 'available-in-connected-mode' }, value), { fields: remapFieldsArrayToFieldsObject(value.fields) });
            return fieldReduceResult;
        }
        fieldReduceResult[current.name] = { value: value };
        return fieldReduceResult;
    }, {});
}
exports.remapFieldsArrayToFieldsObject = remapFieldsArrayToFieldsObject;
/**
 * @param {any} manifestLayout
 * @param {string[]} placeholders
 * @param {ManifestInstance} currentManifest
 * @param {any} request
 * @param {any} response
 * @param {CustomizeRenderFunction} [customizeHook]
 */
function convertManifestLayoutDataToLayoutServiceFormat(manifestLayout, placeholders, currentManifest, request, response, customizeHook) {
    var result = {};
    // we sort by placeholder key length to ensure we create the rendering tree in hierarchy order
    manifestLayout.forEach(function (rendering) {
        var placeholder = getOrCreatePlaceholderPath(rendering.placeholderKey, result);
        var transformedRendering = {
            uid: rendering.uid,
            // shared renderings defined as items instead of on the route will have 'template'; pure renderings will have 'renderingName'
            componentName: rendering.renderingName ? rendering.renderingName : rendering.template,
            dataSource: 'available-in-connected-mode',
        };
        if (rendering.renderingParams) {
            // rendering params go from "name: foo, value: bar" to "foo: bar"
            transformedRendering.params = rendering.renderingParams.reduce(function (reduceResult, current) {
                // eslint-disable-next-line no-param-reassign
                reduceResult[current.name] = current.value.toString();
                return reduceResult;
            }, {});
        }
        if (rendering.dataSource && rendering.dataSource.fields) {
            // fields go from "name: foo, value: bar" to "foo: { value: bar, editable: bar }"
            transformedRendering.fields = remapFieldsArrayToFieldsObject(rendering.dataSource.fields);
        }
        var customizeResult = (customizeHook &&
            customizeHook(transformedRendering, rendering, currentManifest, request, response)) ||
            transformedRendering;
        // adds the rendering object to its placeholder in the LS output
        placeholder.push(customizeResult);
    });
    // ensure empty placeholders are defined
    placeholders.forEach(function (key) {
        if (!result[key]) {
            result[key] = [];
        }
    });
    return result;
}
/**
 * @param {any} route
 * @param {string} language
 * @param {ManifestInstance} currentManifest
 * @param {any} request
 * @param {any} response
 * @param {CustomizeRenderFunction} [customizeRendering]
 */
function defaultCustomizeRoute(route, language, currentManifest, request, response, customizeRendering) {
    var transformedRoute = Object.assign({
        databaseName: 'available-in-connected-mode',
        deviceId: 'available-in-connected-mode',
        itemId: route.id ? route.id : 'available-in-connected-mode',
        itemLanguage: language,
        itemVersion: 1,
        layoutId: 'available-in-connected-mode',
        templateId: 'available-in-connected-mode',
        templateName: route.template ? route.template : 'available-in-connected-mode',
    }, route);
    transformedRoute.placeholders = convertManifestLayoutDataToLayoutServiceFormat(transformedRoute.layout.renderings, transformedRoute.layout.placeholders, currentManifest, request, response, customizeRendering);
    if (transformedRoute.fields) {
        transformedRoute.fields = remapFieldsArrayToFieldsObject(transformedRoute.fields);
    }
    delete transformedRoute.id;
    delete transformedRoute.template;
    delete transformedRoute.layout;
    delete transformedRoute.children;
    return transformedRoute;
}
/**
 * @param {DisconnectedLayoutServiceOptions} config
 */
function createDisconnectedLayoutService(_a) {
    var manifest = _a.manifest, customizeContext = _a.customizeContext, customizeRoute = _a.customizeRoute, manifestLanguageChangeCallback = _a.manifestLanguageChangeCallback, customizeRendering = _a.customizeRendering;
    var currentManifest = manifest;
    console.log("\uD83D\uDD0C  Disconnected " + chalk_1.default.red('Layout Service') + " initializing...\u23F3");
    var service = {
        middleware: function disconnectedLayoutServiceMiddleware(request, response) {
            return __awaiter(this, void 0, void 0, function () {
                var language, routePath, e_1, rawRoute, route, context, result;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            language = (request.query.sc_lang ? request.query.sc_lang : 'en');
                            routePath = request.query.item;
                            if (!(currentManifest.language.toUpperCase() !== language.toUpperCase())) return [3 /*break*/, 6];
                            if (!(manifestLanguageChangeCallback &&
                                typeof manifestLanguageChangeCallback === 'function')) return [3 /*break*/, 5];
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, 3, , 4]);
                            return [4 /*yield*/, manifestLanguageChangeCallback(language)];
                        case 2:
                            currentManifest = _a.sent();
                            return [3 /*break*/, 4];
                        case 3:
                            e_1 = _a.sent();
                            console.error("> [LAYOUT] Error getting manifest in language '" + language + "'", e_1);
                            response.sendStatus(500);
                            return [2 /*return*/];
                        case 4: return [3 /*break*/, 6];
                        case 5:
                            console.error("> [LAYOUT] ERROR: Received request for layout in " + language + " but the manifest data was in " + currentManifest.language + ". To enable switching languages at runtime, please pass 'manifestLanguageChangeCallback: function(newLanguage) { return manifestInNewLanguage; }' in the service creation options.");
                            response.sendStatus(404);
                            return [2 /*return*/];
                        case 6:
                            // no route specified
                            if (!routePath) {
                                console.log('> [LAYOUT] Missing route path "item" in service query string');
                                response.sendStatus(400);
                                return [2 /*return*/];
                            }
                            rawRoute = getRouteData(routePath, currentManifest);
                            if (rawRoute) {
                                route = defaultCustomizeRoute(rawRoute, language, currentManifest, request, response, customizeRendering);
                                if (customizeRoute && typeof customizeRoute === 'function') {
                                    route = customizeRoute(route, rawRoute, currentManifest, request, response);
                                }
                            }
                            context = createDefaultContext(language);
                            if (customizeContext && typeof customizeContext === 'function') {
                                context = customizeContext(context, route, currentManifest, request, response);
                            }
                            if (!route) {
                                route = null;
                            }
                            result = {
                                sitecore: {
                                    context: context,
                                    route: route,
                                },
                            };
                            // no matching route, return 404
                            if (!route) {
                                console.log("> [LAYOUT] Layout for route '" + routePath + "' was not defined. Returning 404.");
                                response.status(404).json(result);
                                return [2 /*return*/];
                            }
                            console.log("> [LAYOUT] served for " + routePath);
                            response.json(result);
                            return [2 /*return*/];
                    }
                });
            });
        },
        updateManifest: function (newManifest) {
            currentManifest = newManifest;
        },
    };
    service.updateManifest(manifest);
    return service;
}
exports.createDisconnectedLayoutService = createDisconnectedLayoutService;
