"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getHttpsTransport = exports.extractProxy = exports.packageDeploy = exports.logJobStatus = exports.finishWatchJobStatusTask = exports.doFingerprintsMatch = exports.normalizeFingerprint = exports.applyCertPinning = void 0;
var chalk_1 = __importDefault(require("chalk"));
var fs_1 = __importDefault(require("fs"));
var https_1 = __importStar(require("https"));
var path_1 = __importDefault(require("path"));
var form_data_1 = __importDefault(require("form-data"));
var axios_1 = __importDefault(require("axios"));
var digest_1 = require("./digest");
// Node does not use system level trusted CAs. This causes issues because SIF likes to install
// using a Windows trusted CA - so SSL connections to Sitecore will fail from Node.
// If the options.acceptCertificate is passed, we disable normal SSL validation and use this function
// to whitelist only a cert with the specific thumbprint - essentially certificate pinning.
/**
 * @param {ClientRequest} req
 * @param {PackageDeployOptions} options
 */
function applyCertPinning(req, options) {
    req.on('socket', function (socket) {
        socket.on('secureConnect', function () {
            var fingerprint = socket.getPeerCertificate().fingerprint;
            // Match the fingerprint with our saved fingerprint
            if (options.acceptCertificate &&
                !doFingerprintsMatch(options.acceptCertificate, fingerprint)) {
                // Abort request, optionally emit an error event
                req.emit('error', new Error("Expected server SSL certificate to have thumbprint " + options.acceptCertificate + " from acceptCertificate, but got " + fingerprint + " from server. This may mean the certificate has changed, or that a malicious certificate is present."));
                return req.abort();
            }
        });
    });
}
exports.applyCertPinning = applyCertPinning;
/**
 * @param {string} fp
 */
function normalizeFingerprint(fp) {
    //
    // The fingerprint for a certificate is a 20-byte value.
    // Such values are typically expressed as strings, but
    // there are many different formats that may be used.
    //
    // For example, the following values all represent
    // the same fingerprint:
    //  * 5E:D1:5E:D4:D4:42:71:CC:30:A5:B6:A2:DA:A4:79:06:67:CB:F6:36
    //  * 5ED15ED4D44271CC30A5B6A2DAA4790667CBF636
    //  * 5e:d1:5e:d4:d4:42:71:cc:30:a5:b6:a2:da:a4:79:06:67:cb:f6:36
    //  * 5ed15ed4d44271cc30a5b6a2daa4790667cbf636
    //
    // Before two fingerprints can be properly compared,
    // they must be converted into the same format. This
    // function implements the logic for that conversion.
    return fp.toLowerCase().replace(new RegExp(':', 'g'), '');
}
exports.normalizeFingerprint = normalizeFingerprint;
/**
 * @param {string} fp1
 * @param {string} fp2
 */
function doFingerprintsMatch(fp1, fp2) {
    return normalizeFingerprint(fp1) === normalizeFingerprint(fp2);
}
exports.doFingerprintsMatch = doFingerprintsMatch;
/**
 * @param {Object} params
 * @param {string[]} params.warnings
 * @param {string[]} params.errors
 * @param {Function} params.resolve
 * @param {Function} params.reject
 */
function finishWatchJobStatusTask(_a) {
    var warnings = _a.warnings, errors = _a.errors, resolve = _a.resolve, reject = _a.reject;
    console.log();
    console.log('Import is complete.');
    if (warnings.length) {
        console.log();
        console.warn(chalk_1.default.yellow('IMPORT WARNING(S) OCCURRED!'));
        warnings.forEach(function (w) { return console.error(chalk_1.default.yellow(w)); });
    }
    if (errors.length) {
        console.log();
        console.error(chalk_1.default.red('IMPORT ERROR(S) OCCURRED!'));
        errors.forEach(function (e) { return console.error(chalk_1.default.red(e)); });
        reject();
    }
    else {
        resolve();
    }
}
exports.finishWatchJobStatusTask = finishWatchJobStatusTask;
/**
 * @param {Object} params
 * @param {string} params.message
 * @param {string} params.entryLevel
 * @param {string[]} params.warnings
 * @param {string[]} params.errors
 */
function logJobStatus(_a) {
    var message = _a.message, entryLevel = _a.entryLevel, warnings = _a.warnings, errors = _a.errors;
    switch (entryLevel) {
        case 'WARN':
            console.warn(chalk_1.default.yellow(message));
            warnings.push(message);
            break;
        case 'ERROR':
            console.error(chalk_1.default.red(message));
            errors.push(message);
            break;
        case 'DEBUG':
            console.log(chalk_1.default.white(message));
            break;
        default:
            console.log(chalk_1.default.green(message));
            break;
    }
}
exports.logJobStatus = logJobStatus;
/**
 * @param {PackageDeployOptions} options
 * @param {string} taskName
 */
function watchJobStatus(options, taskName) {
    return __awaiter(this, void 0, void 0, function () {
        var logOffset, errors, warnings, factors, mac, isHttps, requestBaseOptions;
        return __generator(this, function (_a) {
            logOffset = 0;
            errors = [];
            warnings = [];
            factors = [options.appName, taskName, options.importServiceUrl + "/status"];
            mac = digest_1.hmac(factors, options.secret);
            isHttps = options.importServiceUrl.startsWith('https');
            requestBaseOptions = {
                transport: isHttps ? getHttpsTransport(options) : undefined,
                headers: {
                    'User-Agent': 'Sitecore/JSS-Import',
                    'Cache-Control': 'no-cache',
                    'X-JSS-Auth': mac,
                },
                proxy: extractProxy(options.proxy),
                maxRedirects: 0,
                httpsAgent: isHttps
                    ? new https_1.Agent({
                        // we turn off normal CA cert validation when we are whitelisting a single cert thumbprint
                        rejectUnauthorized: options.acceptCertificate ? false : true,
                        // needed to allow whitelisting a cert thumbprint if a connection is reused
                        maxCachedSessions: options.acceptCertificate ? 0 : undefined,
                    })
                    : undefined,
            };
            if (options.debugSecurity) {
                console.log("Deployment status security factors: " + factors);
                console.log("Deployment status HMAC: " + mac);
            }
            return [2 /*return*/, new Promise(function (resolve, reject) {
                    /**
                     * Send job status request
                     */
                    function sendJobStatusRequest() {
                        axios_1.default
                            .get(options.importServiceUrl + "/status?appName=" + options.appName + "&jobName=" + taskName + "&after=" + logOffset, requestBaseOptions)
                            .then(function (response) {
                            var body = response.data;
                            try {
                                var state = body.state, messages = body.messages;
                                messages.forEach(function (entry) {
                                    logOffset++;
                                    var entryBits = /^(\[([A-Z]+)\] )?(.+)/.exec(entry);
                                    var entryLevel = 'INFO';
                                    var message = entry;
                                    if (entryBits && entryBits[2]) {
                                        entryLevel = entryBits[2];
                                        // 3 = '[] ' in say [INFO] My log message
                                        // we're not using the capture group as the message might be multi-line
                                        message = entry.substring(entryLevel.length + 3);
                                    }
                                    if (message.startsWith('[JSS] - ')) {
                                        message = message.substring(8);
                                    }
                                    logJobStatus({ message: message, entryLevel: entryLevel, warnings: warnings, errors: errors });
                                });
                                if (state === 'Finished') {
                                    finishWatchJobStatusTask({ warnings: warnings, errors: errors, resolve: resolve, reject: reject });
                                    return;
                                }
                                setTimeout(sendJobStatusRequest, 1000);
                            }
                            catch (error) {
                                console.error(chalk_1.default.red("Unexpected error processing reply from import status service: " + error));
                                console.error(chalk_1.default.red("Response: " + body));
                                console.error(chalk_1.default.red('Consult the Sitecore logs for details.'));
                                reject(error);
                            }
                        })
                            .catch(function (error) {
                            console.error(chalk_1.default.red('Unexpected response from import status service. The import task is probably still running; check the Sitecore logs for details.'));
                            if (error.response) {
                                console.error(chalk_1.default.red("Status message: " + error.response.statusText));
                                console.error(chalk_1.default.red("Status: " + error.response.status));
                            }
                            else {
                                console.error(chalk_1.default.red(error.message));
                            }
                            reject();
                        });
                    }
                    setTimeout(sendJobStatusRequest, 1000);
                })];
        });
    });
}
/**
 * @param {PackageDeployOptions} options
 */
function packageDeploy(options) {
    return __awaiter(this, void 0, void 0, function () {
        var packageFile, factors, _a, formData, isHttps, requestBaseOptions;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    if (!options.secret) {
                        throw new Error('Deployment secret was not passed. A shared secret must be configured on both the Sitecore app config and the JS app config');
                    }
                    if (options.secret.length < 32) {
                        throw new Error('Deployment secret was too short. Use a RANDOM (not words or phrases) secret at least 32 characters long.');
                    }
                    packageFile = null;
                    fs_1.default.readdirSync(options.packagePath).forEach(function (file) {
                        if (file.startsWith(options.appName) && file.endsWith('.manifest.zip')) {
                            packageFile = path_1.default.join(options.packagePath, file);
                        }
                    });
                    if (!packageFile) {
                        throw new Error('Package file not found, ensure you have generated the package first.');
                    }
                    _a = [options.appName, options.importServiceUrl];
                    return [4 /*yield*/, digest_1.digest(packageFile)];
                case 1:
                    factors = _a.concat([_b.sent()]);
                    if (options.debugSecurity) {
                        console.log('Security debugging is enabled. Do not use this unless absolutely necessary.');
                        console.log("Deployment secret: " + options.secret);
                        console.log("Deployment security factors: " + factors);
                        console.log("Deployment HMAC: " + digest_1.hmac(factors, options.secret));
                    }
                    formData = new form_data_1.default();
                    formData.append('path', fs_1.default.createReadStream(packageFile));
                    formData.append('appName', options.appName);
                    isHttps = options.importServiceUrl.startsWith('https');
                    requestBaseOptions = {
                        transport: isHttps ? getHttpsTransport(options) : undefined,
                        headers: __assign({ 'User-Agent': 'Sitecore/JSS-Import', 'Cache-Control': 'no-cache', 'X-JSS-Auth': digest_1.hmac(factors, options.secret) }, formData.getHeaders()),
                        proxy: extractProxy(options.proxy),
                        httpsAgent: isHttps
                            ? new https_1.Agent({
                                // we turn off normal CA cert validation when we are whitelisting a single cert thumbprint
                                rejectUnauthorized: options.acceptCertificate ? false : true,
                                // needed to allow whitelisting a cert thumbprint if a connection is reused
                                maxCachedSessions: options.acceptCertificate ? 0 : undefined,
                            })
                            : undefined,
                        maxRedirects: 0,
                    };
                    console.log("Sending package " + packageFile + " to " + options.importServiceUrl + "...");
                    return [2 /*return*/, new Promise(function (resolve, reject) {
                            axios_1.default
                                .post(options.importServiceUrl, formData, requestBaseOptions)
                                .then(function (response) {
                                var body = response.data;
                                console.log(chalk_1.default.green("Sitecore has accepted import task " + body));
                                resolve(body);
                            })
                                .catch(function (error) {
                                console.error(chalk_1.default.red('Unexpected response from import service:'));
                                if (error.response) {
                                    console.error(chalk_1.default.red("Status message: " + error.response.statusText));
                                    console.error(chalk_1.default.red("Status: " + error.response.status));
                                }
                                else {
                                    console.error(chalk_1.default.red(error.message));
                                }
                                reject();
                            });
                        }).then(function (taskName) { return watchJobStatus(options, taskName); })];
            }
        });
    });
}
exports.packageDeploy = packageDeploy;
/**
 * Creates valid proxy object which fit to axios configuration
 * @param {string} [proxy] proxy url
 */
function extractProxy(proxy) {
    if (!proxy)
        return undefined;
    try {
        var proxyUrl = new URL(proxy);
        return {
            protocol: proxyUrl.protocol.slice(0, -1),
            host: proxyUrl.hostname,
            port: +proxyUrl.port,
        };
    }
    catch (error) {
        console.error(chalk_1.default.red("Invalid proxy url provided " + proxy));
        process.exit(1);
    }
}
exports.extractProxy = extractProxy;
/**
 * Provides way to customize axios request adapter
 * in order to execute certificate pinning before request sent:
 * {@link https://github.com/axios/axios/issues/2808}
 * @param {PackageDeployOptions} options
 */
function getHttpsTransport(options) {
    return __assign(__assign({}, https_1.default), { request: function (reqOptions, callback) {
            var req = https_1.default.request(__assign({}, reqOptions), callback);
            applyCertPinning(req, options);
            return req;
        } });
}
exports.getHttpsTransport = getHttpsTransport;
