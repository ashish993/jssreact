"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.startRenderingHostServer = void 0;
const compression_1 = __importDefault(require("compression"));
const express_1 = __importDefault(require("express"));
// import importFresh from 'import-fresh';
// import path from 'path';
const ssrMiddleware_1 = require("./ssrMiddleware");
const defaultAppInvocationInfoResolver_1 = require("./defaultAppInvocationInfoResolver");
/**
 * @param {any} config
 */
function startRenderingHostServer({ port = 0, hostname = 'localhost', hooks = {}, middlewares = {}, enableCompression = true, ssrMiddleware, ssrMiddlewarePath, appInvocationInfoResolver: customAppInvocationInfoResolver, }) {
    const server = express_1.default();
    if (enableCompression) {
        const compressionMiddleware = middlewares.compression && typeof middlewares.compression === 'function'
            ? middlewares.compression
            : compression_1.default();
        server.use(compressionMiddleware);
    }
    const appInvocationInfoResolver = customAppInvocationInfoResolver || defaultAppInvocationInfoResolver_1.getDefaultAppInvocationInfoResolver({});
    const middleware = ssrMiddleware
        ? ssrMiddleware({
            appInvocationInfoResolver,
        })
        : ssrMiddleware_1.ssrMiddleware({
            appInvocationInfoResolver,
        });
    // Give devs a chance to add custom middleware before the SSR middleware is registered.
    invokeHook(hooks.beforeSSRMiddlewareRegistered, server);
    // Otherwise, by default we assume all POST requests should be handled by the SSR middleware.
    server.post(ssrMiddlewarePath || '*', middleware);
    invokeHook(hooks.beforeStaticFileMiddlewareRegistered, server);
    // TODO: register static asset middleware
    // Give devs a chance to add more middleware or whatever prior to starting the server.
    invokeHook(hooks.beforeServerStarted, server);
    // Start the webpack dev server
    server.listen(port, hostname, (err) => {
        if (err) {
            console.error(err);
            return;
        }
        console.log(`Starting rendering host at ${hostname}:${port}`);
        invokeHook(hooks.afterServerStarted, server);
    });
}
exports.startRenderingHostServer = startRenderingHostServer;
/**
 * @param {Function | undefined} hook
 * @param {...any} args
 */
// eslint-disable-next-line @typescript-eslint/ban-types
function invokeHook(hook, ...args) {
    if (hook && typeof hook === 'function') {
        hook(...args);
    }
}
// function getDefaultAppInvocationInfoResolver(baseAppPath: string = './dist') {
//   const resolver: AppInvocationInfoResolver = (bodyJson: any) => {
//     // default resolution assumes folder structure of:
//     // ./dist/{JSSAppName}/{ServerBundleName}.js
//     const modulePath = path.resolve(baseAppPath, bodyJson.id, bodyJson.moduleName);
//     const resolvedModule = importFresh(modulePath);
//     const resolvedRenderFunctionName = bodyJson.functionName || 'renderView';
//     const renderFunction = resolvedModule[resolvedRenderFunctionName];
//     if (!renderFunction) {
//       throw new Error(`The module "${modulePath}" has no export named "${resolvedRenderFunctionName}".
//         Ensure that your server bundle is transpiled to CommonJS (or equivalent) format that can be
//         resolved by Node.js 'require' statement. And ensure that your server entry point exports a function
//         named "${resolvedRenderFunctionName}".`);
//     }
//     const renderFunctionArgs = bodyJson.args;
//     return {
//       renderFunction: (...args) => {
//         console.log(`[SSR] rendering app at ${modulePath} via render function named ${resolvedRenderFunctionName}`);
//         return renderFunction(...args);
//       },
//       renderFunctionArgs,
//     };
//   };
//   return resolver;
// }
